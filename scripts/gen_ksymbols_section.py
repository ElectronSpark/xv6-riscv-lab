#!/usr/bin/env python3
"""
Generate an assembly file containing kernel symbols in the .ksymbols section.

This script takes a kernel.sym file (generated by gen_addrline.sh) and creates
an assembly file that places the symbol data in the .ksymbols section.

Usage:
    gen_ksymbols_section.py <input.sym> <output.S>

The generated assembly file can be compiled and linked with the kernel to
embed the symbol table directly in the kernel image.
"""

import sys
import os

def main():
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <input.sym> <output.S>", file=sys.stderr)
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    if not os.path.exists(input_file):
        print(f"Error: {input_file} not found", file=sys.stderr)
        sys.exit(1)
    
    # Read the symbol data
    with open(input_file, 'rb') as f:
        sym_data = f.read()
    
    # Generate assembly file
    with open(output_file, 'w') as f:
        f.write("/*\n")
        f.write(" * Auto-generated kernel symbols section\n")
        f.write(f" * Source: {input_file}\n")
        f.write(f" * Size: {len(sym_data)} bytes\n")
        f.write(" */\n\n")
        
        f.write('.section .ksymbols, "a", @progbits\n')
        f.write('.global __ksymbols_data_start\n')
        f.write('.global __ksymbols_data_end\n\n')
        
        f.write('__ksymbols_data_start:\n')
        
        # Write data as .byte directives in chunks
        BYTES_PER_LINE = 16
        for i in range(0, len(sym_data), BYTES_PER_LINE):
            chunk = sym_data[i:i + BYTES_PER_LINE]
            hex_bytes = ', '.join(f'0x{b:02x}' for b in chunk)
            f.write(f'    .byte {hex_bytes}\n')
        
        f.write('\n__ksymbols_data_end:\n')
    
    print(f"Generated {output_file} with {len(sym_data)} bytes of symbol data")

if __name__ == '__main__':
    main()
